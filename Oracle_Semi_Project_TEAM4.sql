------------------------------- 테이블 생성 쿼리 -------------------------------

-- ○ 관리자 권한 테이블 생성 및 제약조건 설정
CREATE TABLE ADMIN_AUTHORITY
( AUTHO_NUM     NUMBER(2) 
, AUTHO_NAME    VARCHAR2(20)
, CONSTRAINT AUTHO_NUM_PK PRIMARY KEY(AUTHO_NUM)
);


--○ 관리자 테이블 생성 및 제약조건 설정
CREATE TABLE ADMINS
( ADMIN_ID  VARCHAR2(20)
, AUTHO_NUM NUMBER(2)   CONSTRAINT AUTHO_NUM_NN NOT NULL
, ADM_NAME  VARCHAR2(20)
, ADMIN_PW  VARCHAR2(16) CONSTRAINT ADMIN_PW_NN NOT NULL
, REG_DATE  DATE DEFAULT SYSDATE
, CONSTRAINT ADMIN_ID_PK PRIMARY KEY(ADMIN_ID)
, CONSTRAINT AUTHO_NUM_FK FOREIGN KEY(AUTHO_NUM)
                REFERENCES ADMIN_AUTHORITY(AUTHO_NUM)        
);
ALTER TABLE ADMINS
ADD CONSTRAINT ADMIN_PW_CK CHECK (LENGTH(ADMIN_PW) >= 7);


--○ 교수 테이블 생성 및 제약조건 설정
CREATE TABLE PROFESSORS
( PRO_ID    VARCHAR2(20)                CONSTRAINT PRO_ID_PK PRIMARY KEY
, PRO_SSN   CHAR(14)                    CONSTRAINT PRO_SSN_NN NOT NULL
, PRO_NAME  VARCHAR2(20)
, PRO_PW    VARCHAR2(16)                CONSTRAINT PRO_PW_NN NOT NULL                 
, PRO_REG_DATE  DATE DEFAULT SYSDATE
);
ALTER TABLE PROFESSORS
ADD (CONSTRAINT PRO_PW_CK CHECK(LENGTH(PRO_PW) >= 7)
, CONSTRAINT PRO_SSN_UK UNIQUE(PRO_SSN) );


--○ 학생 테이블 생성 및 제약조건 설정
CREATE TABLE STUDENTS
(
  STU_ID        VARCHAR2(20) CONSTRAINT STU_ID_PK PRIMARY KEY,
  STU_SSN       CHAR(14)     CONSTRAINT STU_SSN_NN NOT NULL,
  STU_NAME      VARCHAR2(20),
  STU_PW        VARCHAR2(20) CONSTRAINT STU_PW_NN NOT NULL,
  STU_REG_DATE  DATE DEFAULT SYSDATE
);
ALTER TABLE PROFESSORS
ADD (CONSTRAINT STU_PW_CK CHECK(LENGTH(STU_PW) >= 7)
, CONSTRAINT STU_SSN_UK UNIQUE(STU_SSN) );


--○ 과목 테이블 생성 및 제약조건 설정
CREATE TABLE SUBJECTS
( SUB_CODE  VARCHAR2(20)
, SUB_NAME  VARCHAR2(40)
, CONSTRAINT SUB_CODE_PK PRIMARY KEY(SUB_CODE)
);


--○ 과정 테이블 생성 및 제약조건 설정
CREATE TABLE COURSES
( COU_CODE  VARCHAR2(20)    CONSTRAINT COU_CODE_PK PRIMARY KEY
, COU_NAME  VARCHAR2(50)    
);


--○ 강의실 테이블 생성 및 제약조건 설정
CREATE TABLE ROOMS
( ROOM_CODE VARCHAR2(20)    CONSTRAINT ROOM_CODE_PK PRIMARY KEY
, ROOM_NAME VARCHAR2(20)    
);


--○ 교재 테이블 생성 및 제약조건 설정
CREATE TABLE BOOKS
( BOOK_CODE     VARCHAR2(20)
, BOOK_NAME     VARCHAR2(40)
, CONSTRAINT BOOK_CODE_PK PRIMARY KEY(BOOK_CODE)
);


--○ 개설과정 테이블 생성 및 제약조건 설정
CREATE TABLE OPENING_COURSES
( OPEN_COU_CODE     NUMBER          CONSTRAINT OPEN_COU_CODE_PK PRIMARY KEY
, ROOM_CODE         VARCHAR2(10)    CONSTRAINT ROOM_CODE_NN NOT NULL
, COU_START_DATE    DATE            
, COU_END_DATE      DATE
, COU_DESC          VARCHAR2(100)
, COU_CODE          VARCHAR2(20)    CONSTRAINT COU_CODE_NN NOT NULL
, CONSTRAINT ROOM_CODE_FK FOREIGN KEY(ROOM_CODE)
             REFERENCES ROOMS(ROOM_CODE)
, CONSTRAINT COU_CODE_FK FOREIGN KEY(COU_CODE)
             REFERENCES COURSES(COU_CODE)
             ON DELETE CASCADE
);


--○ 개설 과목 테이블 생성 및 제약조건 설정
CREATE TABLE OPENING_SUBJECTS
( OPEN_SUB_CODE     VARCHAR2(20)    CONSTRAINT OPEN_SUB_CODE_PK PRIMARY KEY
, PRO_ID            VARCHAR2(20)    CONSTRAINT PRO_ID_NN NOT NULL
, BOOK_CODE         VARCHAR2(20)    CONSTRAINT BOOK_CODE_NN NOT NULL
, SUB_START_DATE    DATE
, SUB_END_DATE      DATE
, NOTE_RATIO        NUMBER(3)       CONSTRAINT NOTE_RATIO_CK 
                                               CHECK(NOTE_RATIO BETWEEN 0 AND 100)
, SKILL_RATIO       NUMBER(3)       CONSTRAINT SKILL_RATIO_CK
                                               CHECK(SKILL_RATIO BETWEEN 0 AND 100)
, ATT_RATIO         NUMBER(3)       CONSTRAINT ATT_RATIO_CK
                                               CHECK(ATT_RATIO BETWEEN 0 AND 100)

, SUB_DESC          VARCHAR2(100)
, SUB_CODE          VARCHAR2(20)    CONSTRAINT SUB_CODE_NN NOT NULL
, OPEN_COU_CODE     VARCHAR2(20)    CONSTRAINT OPEN_COU_CODE_NN NOT NULL
);

ALTER TABLE OPENING_SUBJECTS
ADD (   CONSTRAINT OPS_PRO_ID_FK FOREIGN KEY (PRO_ID)
                   REFERENCES PROFESSOR(PRO_ID)
      , CONSTRAINT OPS_BOOK_CODE_FK FOREIGN KEY (BOOK_CODE)
                   REFERENCES BOOK(BOOK_CODE)
      , CONSTRAINT OPS_SUB_CODE_FK FOREIGN KEY (SUB_CODE)
                   REFERENCES SUBJECT(SUB_CODE)
      , CONSTRAINT OPS_OPEN_COU_CODE FOREIGN KEY (OPEN_COU_CODE)
                   REFERENCES OPENING_COURSES(OPEN_COU_CODE)
    );


--○ 수강신청 테이블 생성 및 제약조건 설정
CREATE TABLE COURSE_APPLICATION
(
  COU_APP_NUM   NUMBER
, STU_ID        VARCHAR2(20)    CONSTRAINT CA_STU_ID_NN NOT NULL
, APP_DATE      DATE
, OPEN_COU_CODE VARCHAR2(20)    CONSTRAINT CA_OPEN_COU_CODE_NN NOT NULL
, CONSTRAINT COU_APP_NUM_PK PRIMARY KEY(COU_APP_NUM)
, CONSTRAINT CA_STU_ID_FK FOREIGN KEY(STU_ID)
                       REFERENCES STUDENTS(STU_ID)
, CONSTRAINT CA_OPEN_COU_CODE_FK FOREIGN KEY(OPEN_COU_CODE)
                              REFERENCES OPENING_COURSES(OPEN_COU_CODE)
                              
);


--○ 성적 테이블 생성 및 제약조건 설정
CREATE TABLE SCORE
( SCORE_CODE    VARCHAR2(20)    CONSTRAINT SCORE_CODE_PK PRIMARY KEY
, NOTE_SCORE    NUMBER(3)       
, SKILL_SCORE   NUMBER(3)
, ATT_SCORE     NUMBER(3)
, OPEN_SUB_CODE VARCHAR2(20)    CONSTRAINT SC_OPEN_SUB_CODE_NN NOT NULL
, COU_APP_NUM   NUMBER          CONSTRAINT SC_COU_APP_NUM_NN NOT NULL
)

ALTER TABLE SCORE
ADD (  CONSTRAINT SC_OPEN_SUB_CODE_FK FOREIGN KEY(OPEN_SUB_CODE)
                 REFERENCES OPENING_SUBJECTS(OPEN_SUB_CODE)
     , CONSTRAINT SC_COU_APP_NUM_FK FOREIGN KEY(COU_APP_NUM)
                 REFERENCES COURSE_APPLICATION(COU_APP_NUM)
     , CONSTRAINT NOTE_SCORE_CK CHECK(NOTE_SCORE BETWEEN 0 AND 100)
     , CONSTRAINT SKILL_SCORE_CK CHECK(SKILL_SCORE BETWEEN 0 AND 100)
     , CONSTRAINT ATT_SCORE_CK CHECK(ATT_SCORE BETWEEN 0 AND 100) );


--○ 중도탈락자 테이블 생성 및 제약조건 설정
CREATE TABLE RETIRE_OUT_STUDENTS
( RETIRE_NO   VARCHAR2(20) CONSTRAINT RETIRE_NO_PK PRIMARY KEY
, RETIRE_DATE DATE         CONSTRAINT RETIRE_DATE_NN NOT NULL
, RETIRE_CODE NUMBER(3) CONSTRAINT RETIRE_CODE_NN NOT NULL
, COU_APP_NUM NUMBER       CONSTRAINT ROS_COU_APP_NUM_NN NOT NULL
);
ALTER TABLE RETIRE_OUT_STUDENTS
ADD ( CONSTRAINT RETIRE_CODE_FK FOREIGN KEY(RETIRE_CODE)
                REFERENCES RETIRE_OUT_REASON(RETIRE_CODE)
    , CONSTRAINT COU_APP_NUM_FK FOREIGN KEY(COU_APP_NUM)
                REFERENCES COURSE_APPLICATION(COU_APP_NUM) );


--○ 중도탈락사유 테이블 생성 및 제약조건 설정
CREATE TABLE RETIRE_OUT_REASON
( RETIRE_CODE   NUMBER(3) CONSTRAINT RETIRE_CODE_PK PRIMARY KEY
, RETIRE_REASON VARCHAR2(20) CONSTRAINT RETIRE_REASON_NN NOT NULL
);


-- 시퀀스 생성 구문 

--○ 수강신청코드 시퀀스 
CREATE SEQUENCE COURSE_APPLICATION_SEQ  
MINVALUE 1 
MAXVALUE 9990 
INCREMENT BY 1 
START WITH 195 
NOCACHE  
NOORDER  
NOCYCLE;

--○ 개설과정코드 시퀀스
CREATE SEQUENCE OPENING_COURSES_SEQ  
MINVALUE 1 
MAXVALUE 9990 
INCREMENT BY 1 
START WITH 15 
NOCACHE  
NOORDER  
NOCYCLE ;

--○ 개설과목코드 시퀀스
CREATE SEQUENCE OPENING_SUBJECTS_SEQ
MINVALUE 1 
MAXVALUE 9990 
INCREMENT BY 1 
START WITH 22 
NOCACHE  
NOORDER  
NOCYCLE ;

-------------------------------- SQL, PL/SQL -----------------------------------

-- [관리자측 요구분석]

--○ 관리자 로그인 PROCEDURE
CREATE OR REPLACE PROCEDURE PRC_ADMIN_LOGIN
( 
  V_ID  IN ADMINS.ADMIN_ID%TYPE
, V_PW  IN ADMINS.ADMIN_PW%TYPE
)
IS
  V2_ID ADMINS.ADMIN_ID%TYPE;
  V2_PW ADMINS.ADMIN_PW%TYPE;
  V_PLAG VARCHAR2(40);

BEGIN
  SELECT ADMIN_ID, ADMIN_PW INTO V2_ID, V2_PW
  FROM ADMINS
  WHERE ADMIN_ID = V_ID AND ADMIN_PW = V_PW;

  IF (V2_ID = V_ID AND V2_PW = V_PW) THEN
    V_PLAG := '로그인 성공';
  ELSE
    V_PLAG := '로그인 실패';
  END IF;

  DBMS_OUTPUT.PUT_LINE(V_PLAG);


EXCEPTION
    WHEN OTHERS THEN
    V_PLAG := '사용자를 찾을 수 없음';
    DBMS_OUTPUT.PUT_LINE(V_PLAG);

    COMMIT;

END;

--○ 교수 테이블 입력 / 수정 / 삭제 이벤트 로그
CREATE OR REPLACE TRIGGER TRG_PROFESSORS_LOG
AFTER 
INSERT OR UPDATE OR DELETE ON PROFESSORS
FOR EACH ROW
BEGIN
    IF (INSERTING) THEN
        INSERT INTO PROFESSORS_LOG(PRO_NAME, MEMO)
        VALUES(:NEW.PRO_NAME, '교수ID가 추가되었습니다.');
    ELSIF (UPDATING) THEN
        INSERT INTO PROFESSORS_LOG(PRO_NAME, MEMO)
        VALUES(:NEW.PRO_NAME, '교수정보가 변경되었습니다.');
    ELSIF (DELETING) THEN
        INSERT INTO PROFESSORS_LOG(PRO_NAME, MEMO)
        VALUES(:OLD.PRO_NAME, '교수ID가 삭제되었습니다.');
    END IF;
END;

--○ 학생 테이블 입력 / 수정 / 삭제 이벤트 로그
CREATE OR REPLACE TRIGGER STUDENTS_EVENTLOG
        AFTER
        INSERT OR UPDATE OR DELETE ON STUDENTS
BEGIN
    IF(INSERTING)
        THEN INSERT INTO STUDENTS_EVENTLOG(MEMO)
             VALUES('INSERT 쿼리가 실행되었습니다.');
    ELSIF(UPDATING)
        THEN INSERT INTO STUDENTS_EVENTLOG(MEMO)
             VALUES('UPDATE 쿼리가 실행되었습니다.');
    ELSIF(DELETING)
        THEN INSERT INTO STUDENTS_EVENTLOG(MEMO)
             VALUES('DELETE 쿼리가 실행되었습니다.');
    END IF;
END;


--[교수 관리 파트]

--○ 교수 사전 등록 PROCEDURE
CREATE OR REPLACE PROCEDURE PRC_PROFESSORS_REGISTRATION
( 
  V_ID   IN ADMINS.ADMIN_ID%TYPE
, V_PW   IN ADMINS.ADMIN_PW%TYPE
, P_NAME IN PROFESSORS.PRO_NAME%TYPE
, P_ID   IN PROFESSORS.PRO_ID%TYPE
, P_SSN  IN PROFESSORS.PRO_SSN%TYPE
)
IS
    V2_ID ADMINS.ADMIN_ID%TYPE;
    V2_PW ADMINS.ADMIN_PW%TYPE;

    V_PLAG NUMBER := 0;
    V_PLAG2 VARCHAR2(40);
BEGIN
    SELECT ADMIN_ID, ADMIN_PW INTO V2_ID, V2_PW
    FROM ADMINS
    WHERE ADMIN_ID = V_ID AND ADMIN_PW = V_PW;

    IF (V2_ID = V_ID AND V2_PW = V_PW) THEN
        V_PLAG := 1;
    ELSE
        V_PLAG := 0;
    END IF;

    IF V_PLAG = 1 THEN
        -- 바로 INSERT 문에서 SUBSTR(P_SSN, 8, 7) 사용
        INSERT INTO PROFESSORS(PRO_ID, PRO_SSN, PRO_NAME, PRO_PW)
        VALUES(P_ID, P_SSN, P_NAME, SUBSTR(P_SSN, 8, 7));
    ELSE
        V_PLAG2 := '비밀번호가 틀립니다.';
    END IF;

    DBMS_OUTPUT.PUT_LINE(V_PLAG2);

    EXCEPTION
  --WHEN NO_DATA_FOUND THEN
    WHEN OTHERS THEN
    V_PLAG2 := '이미 존재하고 있습니다.';
    DBMS_OUTPUT.PUT_LINE(V_PLAG2);

    COMMIT;
    
END;

--○ 교수 정보 수정 / 삭제 TRIGGER
CREATE OR REPLACE TRIGGER TRG_PROFESSORS_UPDATE
        AFTER 
        UPDATE OR DELETE ON PROFESSORS
        FOR EACH ROW
BEGIN
        IF (UPDATING)
            THEN UPDATE OPENING_SUBJECTS
                 SET PRO_ID = :NEW.PRO_ID
                 WHERE PRO_ID = :OLD.PRO_ID;

        ELSIF (DELETING) THEN

        DELETE FROM SCORE
        WHERE OPEN_SUB_CODE IN (SELECT OPEN_SUB_CODE
                                FROM OPENING_SUBJECTS 
                                WHERE PRO_ID = :OLD.PRO_ID);

        -- 그 후 OPENING_SUBJECTS 테이블의 행을 삭제
        DELETE FROM OPENING_SUBJECTS
        WHERE PRO_ID = :OLD.PRO_ID;
        END IF;
END;

--○ 모든 교수 정보 출력 / 출력 정보(교수명, 담당과목, 과목기간, 교재, 강의실, 강의진행여부) VIEW
CREATE OR REPLACE VIEW VIEW_ADMINS ("교수이름", "과목이름", "과목기간", "교재", "강의실", "강의여부") AS 
SELECT P.PRO_NAME "교수이름",S.SUB_NAME "과목이름",OS.SUB_START_DATE || ' ~ ' || OS.SUB_END_DATE "과목기간",B.BOOK_NAME"교재"
 , R.ROOM_NAME "강의실", CASE WHEN OS.SUB_START_DATE <= SYSDATE AND OS.SUB_END_DATE >= SYSDATE THEN '강의중'
                     WHEN OS.SUB_END_DATE <= SYSDATE THEN '강의종료'
                ELSE '강의예정' 
                END "강의여부"
FROM PROFESSORS P JOIN opening_subjects OS
ON P.PRO_ID = OS.PRO_ID
JOIN SUBJECTS S
ON S.SUB_CODE = OS.SUB_CODE
JOIN SCORE E
ON E.OPEN_SUB_CODE = OS.OPEN_SUB_CODE
JOIN OPENING_COURSES OC
ON OC.OPEN_COU_CODE = OS.OPEN_COU_CODE
JOIN COURSES C
ON C.COU_CODE = OC.COU_CODE
JOIN ROOMS R
ON R.ROOM_CODE = OC.ROOM_CODE
JOIN BOOKS B
ON B.BOOK_CODE = OS.BOOK_CODE;

--[과정 관리 파트]

--○ 모든 과정 정보 출력 / 출력 정보(과정명, 강의실명, 과목명, 과목 기간, 교재명, 교수자명) VIEW
CREATE OR REPLACE VIEW VIEW_COURSES
AS
SELECT C.COU_NAME 과정명, R.ROOM_NAME 강의실명
, S.SUB_NAME 과목명
, TO_CHAR(OS.SUB_START_DATE||' ~ '||OS.SUB_END_DATE) "과목 기간"
, B.BOOK_NAME 교재명
, P.PRO_NAME 교수자명, PRO_SSN "교수 주민번호"
FROM PROFESSORS P JOIN OPENING_SUBJECTS OS
ON P.PRO_ID = OS.PRO_ID
JOIN SUBJECTS S
ON OS.SUB_CODE = S.SUB_CODE
JOIN BOOKS B
ON OS.BOOK_CODE = B.BOOK_CODE
JOIN OPENING_COURSES OC 
ON OC.OPEN_COU_CODE = OS.OPEN_COU_CODE
JOIN COURSES C 
ON OC.COU_CODE = C.COU_CODE
JOIN ROOMS R
ON OC.ROOM_CODE = R.ROOM_CODE;

--○ 과정 정보 수정 PROCEDURE
CREATE OR REPLACE PROCEDURE PRC_OPEN_COU_UPDATE
( 
  V_OPEN_COU_CODE   IN OPENING_COURSES.OPEN_COU_CODE%TYPE,
  V_COU_CODE        IN OPENING_COURSES.COU_CODE%TYPE,
  V_COU_START_DATE  IN OPENING_COURSES.COU_START_DATE%TYPE,
  V_COU_END_DATE    IN OPENING_COURSES.COU_END_DATE%TYPE,
  V_ROOM_CODE       IN OPENING_COURSES.ROOM_CODE%TYPE
)  
IS
    V_EXISTING_ROOM_CODE        OPENING_COURSES.ROOM_CODE%TYPE;
    V_EXISTING_COU_CODE         OPENING_COURSES.COU_CODE%TYPE;
    V_EXISTING_START_DATE       OPENING_COURSES.COU_START_DATE%TYPE;
    V_EXISTING_END_DATE         OPENING_COURSES.COU_END_DATE%TYPE;
    V_START_MIN_DATE            OPENING_SUBJECTS.SUB_START_DATE%TYPE;
    V_END_MAX_DATE              OPENING_SUBJECTS.SUB_END_DATE%TYPE;
    
    V_EXISTING_END_DATE2        OPENING_COURSES.COU_END_DATE%TYPE;

    USER_DEFINE_ERROR    EXCEPTION;                         -- 사용자 정의 예외
    
BEGIN
    SELECT COU_END_DATE INTO V_EXISTING_END_DATE2
    FROM OPENING_COURSES
    WHERE OPEN_COU_CODE= V_OPEN_COU_CODE;

    -- 기존 과정 정보 조회
    DECLARE
        CURSOR CUR_OPENING_COURSES IS
            SELECT COU_CODE, COU_START_DATE, COU_END_DATE, ROOM_CODE 
            FROM OPENING_COURSES
            WHERE ROOM_CODE = V_ROOM_CODE
                  AND OPEN_COU_CODE != V_OPEN_COU_CODE;

    BEGIN
        OPEN CUR_OPENING_COURSES;
        
        LOOP
        
        FETCH CUR_OPENING_COURSES INTO V_EXISTING_COU_CODE, V_EXISTING_START_DATE, V_EXISTING_END_DATE, V_EXISTING_ROOM_CODE;
        
            EXIT WHEN CUR_OPENING_COURSES%NOTFOUND;
            DBMS_OUTPUT.PUT_LINE('▦▦▦▦▦▦▦▦▦▦▦▦▦▦▦▦▦▦▦▦▦▦▦▦▦▦▦▦');
            DBMS_OUTPUT.PUT_LINE('기존 개설과정코드 : ' || V_EXISTING_COU_CODE);
            DBMS_OUTPUT.PUT_LINE('기존 개설과정 시작일 : ' || V_EXISTING_START_DATE);
            DBMS_OUTPUT.PUT_LINE('기존 개설과정 종료일 : ' || V_EXISTING_END_DATE);
            DBMS_OUTPUT.PUT_LINE('기존 개설과정 강의실 코드 : ' || V_EXISTING_ROOM_CODE);
            DBMS_OUTPUT.PUT_LINE('▦▦▦▦▦▦▦▦▦▦▦▦▦▦▦▦▦▦▦▦▦▦▦▦▦▦▦▦');
       FETCH CUR_OPENING_COURSES INTO V_EXISTING_COU_CODE, V_EXISTING_START_DATE, V_EXISTING_END_DATE, V_EXISTING_ROOM_CODE;
       
            IF 
            (
                V_EXISTING_ROOM_CODE IS NOT NULL
                AND (
                        (V_COU_START_DATE BETWEEN V_EXISTING_START_DATE AND V_EXISTING_END_DATE)
                        OR (V_COU_END_DATE BETWEEN V_EXISTING_START_DATE AND V_EXISTING_END_DATE)
                        OR (V_EXISTING_START_DATE BETWEEN V_COU_START_DATE AND V_COU_END_DATE)
                        OR (V_EXISTING_END_DATE BETWEEN V_COU_START_DATE AND V_COU_END_DATE)
                    )
            )
            THEN
                RAISE USER_DEFINE_ERROR;
            END IF;
          
        END LOOP;
               
        CLOSE CUR_OPENING_COURSES;
    EXCEPTION
        WHEN NO_DATA_FOUND
        THEN
            -- 예외가 발생하면 해당 변수들을 초기화
            V_EXISTING_ROOM_CODE := NULL;
            V_EXISTING_COU_CODE := NULL;
            V_EXISTING_START_DATE := NULL;
            V_EXISTING_END_DATE := NULL;
    END;

    -- 중복되는 과정이나 강의실이 있으면 예외를 발생시킴

       -- 이미 종료된 과정인 경우 예외 발생
    IF  V_EXISTING_END_DATE2 < SYSDATE 
    THEN RAISE_APPLICATION_ERROR(-20020, '이미 종료된 과정입니다.'); 
    END IF;
    
    IF V_COU_START_DATE > V_COU_END_DATE
    THEN RAISE_APPLICATION_ERROR(-20021, '과정 종료일이 과정 시작일보다 빠릅니다.');
    END IF;


    -- 트랜잭션 시작
    BEGIN
        -- 과정 정보 업데이트
        UPDATE OPENING_COURSES
        SET COU_CODE = V_COU_CODE, COU_START_DATE = V_COU_START_DATE, COU_END_DATE = V_COU_END_DATE, ROOM_CODE = V_ROOM_CODE
        WHERE OPEN_COU_CODE = V_OPEN_COU_CODE;

        -- 트랜잭션 커밋
        COMMIT;
    EXCEPTION
        WHEN OTHERS THEN
            -- 다른 예외가 발생하면 롤백
            ROLLBACK;
            -- 롤백 후 다시 예외를 발생시켜 상위 레벨에서 예외처리할 수 있도록 함
            RAISE;
    END;    
    
    SELECT MIN(SUB_START_DATE),MAX(SUB_END_DATE) INTO V_START_MIN_DATE, V_END_MAX_DATE 
    FROM OPENING_SUBJECTS
    WHERE OPEN_COU_CODE = V_OPEN_COU_CODE;

    
    IF V_START_MIN_DATE < V_COU_START_DATE OR V_COU_END_DATE < V_END_MAX_DATE
    THEN RAISE_APPLICATION_ERROR(-20022, '과정기간이 과목기간보다 짧습니다.'); 
    END IF;

EXCEPTION
    WHEN USER_DEFINE_ERROR
    THEN
        -- 사용자 정의 예외가 발생하면 에러 메시지 출력
        RAISE_APPLICATION_ERROR(-20010, '과정이 중복되거나 강의실이 중복됩니다.');
    WHEN NO_DATA_FOUND
    THEN
        -- 데이터를 찾지 못하면 예외 발생
        RAISE_APPLICATION_ERROR(-20011, '해당 강의실에 이미 해당 과정이 개설되어 있습니다.');
    WHEN OTHERS
    THEN
        -- 다른 예외가 발생하면 롤백
        ROLLBACK;
        -- 롤백 후 다시 예외를 발생시켜 상위 레벨에서 예외처리할 수 있도록 함
        RAISE;
END;

--[과목 관리 파트]

--○ 한개 과정당 과목 사전 등록 / 입력정보(과정명, 과목명,과목 기간, 교재 명, 교수 명) PROCEDURE
CREATE OR REPLACE PROCEDURE PRC_OP_SUB_INSERT
( V_OPEN_COU_CODE   IN OPENING_COURSES.OPEN_COU_CODE%TYPE    -- 개설과정코드
, V_SUB_CODE        IN SUBJECTS.SUB_CODE%TYPE                -- 과목코드
, V_SUB_START_DATE  IN OPENING_SUBJECTS.SUB_START_DATE%TYPE  -- 개설과목시작일
, V_SUB_END_DATE    IN OPENING_SUBJECTS.SUB_END_DATE%TYPE    -- 개설과목종료일
, V_BOOK_CODE       IN BOOKS.BOOK_CODE%TYPE                  -- 교재코드
, V_PRO_ID          IN PROFESSORS.PRO_ID%TYPE                -- 담당교수아이디
, V_SUB_DESC        IN OPENING_SUBJECTS.SUB_DESC%TYPE        -- 과목설명
)
IS
    V_SUB_START_DATE2  OPENING_SUBJECTS.SUB_START_DATE%TYPE;  -- 비교개설과목시작일2
    V_SUB_END_DATE2    OPENING_SUBJECTS.SUB_END_DATE%TYPE;    -- 비교개설과목종료일2
    V_SUB_CODE2        SUBJECTS.SUB_NAME%TYPE;                -- 비교개설과목코드2
    V_SUB_START_DATE3  OPENING_SUBJECTS.SUB_START_DATE%TYPE;  -- 비교개설과목시작일3
    V_SUB_END_DATE3    OPENING_SUBJECTS.SUB_END_DATE%TYPE;    -- 비교개설과목종료일3
    V_COU_START_DATE   OPENING_COURSES.COU_START_DATE%TYPE;   -- 개설과정시작일
    V_COU_END_DATE     OPENING_COURSES.COU_END_DATE%TYPE;     -- 개설과정종료일


    CURSOR CUR_OP_SUB_SELECT
    IS
    SELECT SUB_START_DATE, SUB_END_DATE, SUB_CODE             -- 과목시작일과 과목종료일을 조회
    FROM OPENING_SUBJECTS
    WHERE OPEN_COU_CODE = V_OPEN_COU_CODE;                    -- 해당 개설과정에 들어있는 과목이면

    CURSOR CUR_OP_SUB_SELECT2
    IS
    SELECT SUB_START_DATE, SUB_END_DATE
    FROM OPENING_SUBJECTS
    WHERE PRO_ID = V_PRO_ID;
BEGIN

    -- 변수에 값 받아오기
    SELECT COU_START_DATE, COU_END_DATE INTO V_COU_START_DATE, V_COU_END_DATE
    FROM OPENING_COURSES
    WHERE OPEN_COU_CODE = V_OPEN_COU_CODE;

    -- 오픈커서1
    OPEN CUR_OP_SUB_SELECT;

    -- 반복문을 활용하여 처리
    LOOP
        FETCH CUR_OP_SUB_SELECT INTO V_SUB_START_DATE2, V_SUB_END_DATE2, V_SUB_CODE2;

        IF (V_SUB_START_DATE BETWEEN V_SUB_START_DATE2 AND V_SUB_END_DATE2) OR (V_SUB_END_DATE BETWEEN V_SUB_START_DATE2 AND V_SUB_END_DATE2)
            OR (V_SUB_START_DATE2 BETWEEN V_SUB_START_DATE AND V_SUB_END_DATE) OR (V_SUB_END_DATE2 BETWEEN V_SUB_START_DATE AND V_SUB_END_DATE)
            THEN RAISE_APPLICATION_ERROR(-20100,'해당 개설과정 안의 다른 과목과 기간이 중복됩니다');
        ELSIF (V_SUB_CODE = V_SUB_CODE2)
            THEN RAISE_APPLICATION_ERROR(-20101,'해당 개설과정 안에 다른 과목과 과목코드가 중복됩니다');
        END IF;

        EXIT WHEN CUR_OP_SUB_SELECT%NOTFOUND;    
    END LOOP;
    -- 클로즈커서1
    CLOSE CUR_OP_SUB_SELECT;

    -- 오픈커서2
    OPEN CUR_OP_SUB_SELECT2;

       -- 반복문을 활용하여 처리
    LOOP
        FETCH CUR_OP_SUB_SELECT2 INTO V_SUB_START_DATE3, V_SUB_END_DATE3;

        IF (V_SUB_START_DATE BETWEEN V_SUB_START_DATE3 AND V_SUB_END_DATE3) OR (V_SUB_END_DATE BETWEEN V_SUB_START_DATE3 AND V_SUB_END_DATE3)
            OR (V_SUB_START_DATE3 BETWEEN V_SUB_START_DATE AND V_SUB_END_DATE) OR (V_SUB_END_DATE3 BETWEEN V_SUB_START_DATE AND V_SUB_END_DATE)
            THEN RAISE_APPLICATION_ERROR(-20102,'교수가 담당한 다른 과목과 기간이 겹칩니다');
        END IF;

        EXIT WHEN CUR_OP_SUB_SELECT2%NOTFOUND;    
    END LOOP;  
    -- 클로즈커서2
    CLOSE CUR_OP_SUB_SELECT2;


    IF(V_COU_START_DATE > V_SUB_START_DATE) OR (V_SUB_END_DATE> V_COU_END_DATE)
        THEN RAISE_APPLICATION_ERROR(-20103,'입력된 개설과목기간이 해당 과정의 기간을 초과합니다');
    ELSIF (V_SUB_START_DATE > V_SUB_END_DATE)
        THEN RAISE_APPLICATION_ERROR(-20104,'개설과목 기간의 종료일이 시작일보다 빠릅니다');
    ELSIF (V_SUB_START_DATE < SYSDATE)
        THEN RAISE_APPLICATION_ERROR(-20105,'과목시작일이 현재 날짜보다 앞선 날짜는 등록불가능합니다');
    END IF;

    -- 개설과목 데이터 INSERT
    INSERT INTO OPENING_SUBJECTS(OPEN_SUB_CODE, PRO_ID, BOOK_CODE, SUB_START_DATE, SUB_END_DATE, SUB_DESC, SUB_CODE, OPEN_COU_CODE)
    VALUES('OS'||LPAD(TO_CHAR(OPENING_SUBJECTS_SEQ.NEXTVAL), 4, '0'), V_PRO_ID, V_BOOK_CODE, V_SUB_START_DATE, V_SUB_END_DATE, V_SUB_DESC, V_SUB_CODE, V_OPEN_COU_CODE);


    -- 커밋
    COMMIT;

END;

--○ 과목 정보 출력 / 출력 정보(과정명, 강의실, 과목명, 과목 기간, 교재 명, 교수자 명) VIEW
CREATE OR REPLACE VIEW VIEW_SUBJECTS ("과정명", "강의실명", "과목명", "과목기간", "교재명", "교수자명", "교수 주민번호") AS 
SELECT COU_NAME 과정명, ROOM_NAME 강의실명, SUB_NAME 과목명
 , TO_CHAR(OS.SUB_START_DATE||' ~ '||OS.SUB_END_DATE) 과목기간
 , BOOK_NAME 교재명, PRO_NAME 교수자명, PRO_SSN "교수 주민번호"
FROM COURSES C JOIN OPENING_COURSES OC
ON C.COU_CODE = OC.COU_CODE
JOIN ROOMS R
ON OC.ROOM_CODE = R.ROOM_CODE
JOIN OPENING_SUBJECTS OS
ON OC.OPEN_COU_CODE = OS.OPEN_COU_CODE
JOIN SUBJECTS S
ON OS.SUB_CODE = S.SUB_CODE
JOIN BOOKS B
ON OS.BOOK_CODE = B.BOOK_CODE
JOIN PROFESSORS P
ON OS.PRO_ID = P.PRO_ID;

--○ 과목 정보 수정 PROCEDURE
CREATE OR REPLACE PROCEDURE PRC_OP_SUB_UPDATE
( V_OPEN_SUB_CODE   IN OPENING_SUBJECTS.OPEN_SUB_CODE%TYPE   -- 개설과목코드
, V_OPEN_COU_CODE   IN OPENING_COURSES.OPEN_COU_CODE%TYPE    -- 개설과정코드
, V_SUB_START_DATE  IN OPENING_SUBJECTS.SUB_START_DATE%TYPE  -- 개설과목시작일
, V_SUB_END_DATE    IN OPENING_SUBJECTS.SUB_END_DATE%TYPE    -- 개설과목종료일
, V_BOOK_CODE       IN BOOKS.BOOK_CODE%TYPE                  -- 교재코드
, V_PRO_ID          IN PROFESSORS.PRO_ID%TYPE                -- 담당교수아이디
, V_SUB_DESC        IN OPENING_SUBJECTS.SUB_DESC%TYPE        -- 과목설명
)
IS
    V_SUB_START_DATE2  OPENING_SUBJECTS.SUB_START_DATE%TYPE;  -- 비교개설과목시작일2
    V_SUB_END_DATE2    OPENING_SUBJECTS.SUB_END_DATE%TYPE;    -- 비교개설과목종료일2
    V_SUB_START_DATE3  OPENING_SUBJECTS.SUB_START_DATE%TYPE;  -- 비교개설과목시작일3
    V_SUB_END_DATE3    OPENING_SUBJECTS.SUB_END_DATE%TYPE;    -- 비교개설과목종료일3
    V_COU_START_DATE   OPENING_COURSES.COU_START_DATE%TYPE;   -- 개설과정시작일
    V_COU_END_DATE     OPENING_COURSES.COU_END_DATE%TYPE;     -- 개설과정종료일
    V_SUB_END_DATE4    OPENING_SUBJECTS.SUB_END_DATE%TYPE;    -- 비교개설과목종료일4

    CURSOR CUR_OP_SUB_SELECT
    IS
    SELECT SUB_START_DATE, SUB_END_DATE             -- 과목시작일과 과목종료일을 조회
    FROM OPENING_SUBJECTS
    WHERE OPEN_COU_CODE = V_OPEN_COU_CODE AND OPEN_SUB_CODE!=V_OPEN_SUB_CODE;          -- 해당 개설과정에 들어있는 과목이면

    CURSOR CUR_OP_SUB_SELECT2
    IS
    SELECT SUB_START_DATE, SUB_END_DATE
    FROM OPENING_SUBJECTS
    WHERE PRO_ID = V_PRO_ID AND OPEN_SUB_CODE!=V_OPEN_SUB_CODE;
BEGIN

    -- 변수에 값 받아오기
    SELECT COU_START_DATE, COU_END_DATE INTO V_COU_START_DATE, V_COU_END_DATE
    FROM OPENING_COURSES
    WHERE OPEN_COU_CODE = V_OPEN_COU_CODE;

    SELECT SUB_END_DATE INTO V_SUB_END_DATE4
    FROM OPENING_SUBJECTS
    WHERE OPEN_SUB_CODE = V_OPEN_SUB_CODE;


    -- 오픈커서1
    OPEN CUR_OP_SUB_SELECT;

    -- 반복문을 활용하여 처리
    LOOP
        FETCH CUR_OP_SUB_SELECT INTO V_SUB_START_DATE2, V_SUB_END_DATE2;

        IF (V_SUB_START_DATE BETWEEN V_SUB_START_DATE2 AND V_SUB_END_DATE2) OR (V_SUB_END_DATE BETWEEN V_SUB_START_DATE2 AND V_SUB_END_DATE2)
            OR (V_SUB_START_DATE2 BETWEEN V_SUB_START_DATE AND V_SUB_END_DATE) OR (V_SUB_END_DATE2 BETWEEN V_SUB_START_DATE AND V_SUB_END_DATE)
            THEN RAISE_APPLICATION_ERROR(-20200,'해당 개설과정 안의 다른 과목과 기간이 중복됩니다');
        END IF;

        EXIT WHEN CUR_OP_SUB_SELECT%NOTFOUND;    
    END LOOP;
    -- 클로즈커서1
    CLOSE CUR_OP_SUB_SELECT;

    -- 오픈커서2
    OPEN CUR_OP_SUB_SELECT2;

       -- 반복문을 활용하여 처리
    LOOP
        FETCH CUR_OP_SUB_SELECT2 INTO V_SUB_START_DATE3, V_SUB_END_DATE3;

        IF (V_SUB_START_DATE BETWEEN V_SUB_START_DATE3 AND V_SUB_END_DATE3) OR (V_SUB_END_DATE BETWEEN V_SUB_START_DATE3 AND V_SUB_END_DATE3)
            OR (V_SUB_START_DATE3 BETWEEN V_SUB_START_DATE AND V_SUB_END_DATE) OR (V_SUB_END_DATE3 BETWEEN V_SUB_START_DATE AND V_SUB_END_DATE)
            THEN RAISE_APPLICATION_ERROR(-20201,'교수가 담당한 다른 과목과 기간이 겹칩니다');
        END IF;

        EXIT WHEN CUR_OP_SUB_SELECT2%NOTFOUND;    
    END LOOP;  
    -- 클로즈커서2
    CLOSE CUR_OP_SUB_SELECT2;


    IF(V_COU_START_DATE > V_SUB_START_DATE) OR (V_SUB_END_DATE > V_COU_END_DATE)
        THEN RAISE_APPLICATION_ERROR(-20202,'입력된 개설과목기간이 해당 과정의 기간을 초과합니다');
    ELSIF (V_SUB_START_DATE > V_SUB_END_DATE)
        THEN RAISE_APPLICATION_ERROR(-20203,'개설과목 기간의 종료일이 시작일보다 빠릅니다');
    ELSIF (V_SUB_END_DATE4 < SYSDATE)
        THEN RAISE_APPLICATION_ERROR(-20204,'수강기간이 종료된 과목이므로 정보수정이 불가능합니다');
    ELSIF (V_SUB_START_DATE < SYSDATE)
        THEN RAISE_APPLICATION_ERROR(-20205,'과목시작일이 현재 날짜보다 앞선 날짜는 등록불가능합니다');
    END IF;

    -- 개설과목 데이터 UPDATE
    UPDATE OPENING_SUBJECTS
    SET PRO_ID = V_PRO_ID, BOOK_CODE = V_BOOK_CODE, SUB_START_DATE = V_SUB_START_DATE
    , SUB_END_DATE = V_SUB_END_DATE, SUB_DESC = V_SUB_DESC, OPEN_COU_CODE = V_OPEN_COU_CODE
    WHERE OPEN_SUB_CODE = V_OPEN_SUB_CODE;


    -- 커밋
    COMMIT;

END;

--○ 과목 정보 수정 / 삭제 TRIGGER
CREATE OR REPLACE TRIGGER TRG_OPEN_SUB_UPDATE_DELETE
            AFTER
            UPDATE OR DELETE ON OPENING_SUBJECTS
            FOR EACH ROW
            
BEGIN

    IF (UPDATING)
        THEN UPDATE SCORE
             SET OPEN_SUB_CODE = :NEW.OPEN_SUB_CODE
             WHERE OPEN_SUB_CODE = :OLD.OPEN_SUB_CODE;

    ELSIF (DELETING) 

        THEN

        IF NOT (SYSDATE < :OLD.SUB_START_DATE)
            THEN RAISE_APPLICATION_ERROR(-20024, '이미 시작된 과목이므로 삭제가 불가능합니다');
        END IF;


        DELETE FROM SCORE
        WHERE OPEN_SUB_CODE = :OLD.OPEN_SUB_CODE;

    END IF;
END;

--○ 모든 학생 정보 출력 / 출력 정보(학생이름, 과정명, 수강과목, 수강과목 총점), ※ 중도탈락사실 확인 VIEW

  CREATE OR REPLACE VIEW VIEW_STUDENTS ("학생이름", "주민등록번호", "과정명", "과목명", "수강과목총점", "분류") AS 
  (
    SELECT 
        ST.STU_NAME "학생이름"
      , ST.STU_SSN "주민등록번호"
      , C.COU_NAME "과정명"
      , SU.SUB_NAME "과목명"
      , SC.NOTE_SCORE + SC.SKILL_SCORE + SC.ATT_SCORE "수강과목총점"
      , '수강생' "분류"
    FROM STUDENTS ST
         JOIN COURSE_APPLICATION CA 
         ON ST.STU_ID = CA.STU_ID
         JOIN OPENING_COURSES OC 
         ON CA.OPEN_COU_CODE = OC.OPEN_COU_CODE
         JOIN COURSES C 
         ON OC.COU_CODE = C.COU_CODE
         JOIN SCORE SC 
         ON CA.COU_APP_NUM = SC.COU_APP_NUM
         JOIN OPENING_SUBJECTS OS
         ON SC.OPEN_SUB_CODE = OS.OPEN_SUB_CODE
         JOIN SUBJECTS SU 
         ON OS.SUB_CODE = SU.SUB_CODE 
    WHERE 
        CA.COU_APP_NUM NOT IN (SELECT COU_APP_NUM FROM RETIRE_OUT_STUDENTS)    

    UNION ALL

    SELECT 
        ST.STU_NAME "학생이름"
      , ST.STU_SSN "주민등록번호"
      , C.COU_NAME "과정명"
      , SU.SUB_NAME "과목명"
      , SC.NOTE_SCORE + SC.SKILL_SCORE + SC.ATT_SCORE "수강과목총점"
      , '중도탈락자' "분류"
    FROM STUDENTS ST
         JOIN COURSE_APPLICATION CA 
         ON ST.STU_ID = CA.STU_ID
         JOIN OPENING_COURSES OC 
         ON CA.OPEN_COU_CODE = OC.OPEN_COU_CODE
         JOIN COURSES C 
         ON OC.COU_CODE = C.COU_CODE
         JOIN SCORE SC 
         ON CA.COU_APP_NUM = SC.COU_APP_NUM
         JOIN OPENING_SUBJECTS OS
         ON SC.OPEN_SUB_CODE = OS.OPEN_SUB_CODE
         JOIN SUBJECTS SU 
         ON OS.SUB_CODE = SU.SUB_CODE 
    WHERE 
        CA.COU_APP_NUM IN (SELECT COU_APP_NUM FROM RETIRE_OUT_STUDENTS)         
);

--○ 학생 정보 수정 / 삭제 TRIGGER
CREATE OR REPLACE TRIGGER TRG_STUDENTS
    AFTER DELETE OR UPDATE ON STUDENTS
    FOR EACH ROW
BEGIN
    IF UPDATING THEN
        UPDATE COURSE_APPLICATION
        SET STU_ID = :NEW.STU_ID
        WHERE STU_ID = :OLD.STU_ID;
    ELSIF DELETING THEN
        DELETE FROM SCORE
        WHERE COU_APP_NUM IN (SELECT COU_APP_NUM 
                              FROM COURSE_APPLICATION 
                              WHERE STU_ID = :OLD.STU_ID);

        DELETE FROM RETIRE_OUT_STUDENTS
        WHERE COU_APP_NUM IN (SELECT COU_APP_NUM 
                              FROM COURSE_APPLICATION 
                              WHERE STU_ID = :OLD.STU_ID);

        DELETE FROM COURSE_APPLICATION
        WHERE STU_ID = :OLD.STU_ID;        

    END IF;
END;

--○ 과정 사전 등록 / 입력정보(과정명, 과정기간, 강의실정보) PROCEDURE
CREATE OR REPLACE PROCEDURE PRC_OPENING_COURSES_INSERT (
    V_COU_CODE        IN COURSES.COU_CODE%TYPE,           
    V_COU_START_DATE  IN OPENING_COURSES.COU_START_DATE%TYPE, 
    V_COU_END_DATE    IN OPENING_COURSES.COU_END_DATE%TYPE,   
    V_ROOM_CODE       IN OPENING_COURSES.ROOM_CODE%TYPE      
)
IS
    V_EXISTING_ROOM_CODE OPENING_COURSES.ROOM_CODE%TYPE;
    V_EXISTING_COU_START_DATE OPENING_COURSES.COU_START_DATE%TYPE;
    V_EXISTING_COU_END_DATE OPENING_COURSES.COU_END_DATE%TYPE;
    V_EXISTING_COU_CODE OPENING_COURSES.COU_CODE%TYPE;
    V_COURSE_FOUND NUMBER := 0;
    USER_DEFINE_ERROR EXCEPTION;

BEGIN
    FOR CourseRec IN (
        SELECT COU_CODE, COU_START_DATE, COU_END_DATE, ROOM_CODE 
        FROM OPENING_COURSES 
        WHERE ROOM_CODE = V_ROOM_CODE
    )
    LOOP
        IF (V_COU_START_DATE BETWEEN CourseRec.COU_START_DATE AND CourseRec.COU_END_DATE) OR
           (V_COU_END_DATE BETWEEN CourseRec.COU_START_DATE AND CourseRec.COU_END_DATE) OR
           (CourseRec.COU_START_DATE BETWEEN V_COU_START_DATE AND V_COU_END_DATE) OR
           (CourseRec.COU_END_DATE BETWEEN V_COU_START_DATE AND V_COU_END_DATE) THEN
            V_COURSE_FOUND := 1;
            EXIT;
        END IF;
    END LOOP;

    IF V_COURSE_FOUND = 0 THEN
        INSERT INTO OPENING_COURSES(OPEN_COU_CODE, ROOM_CODE, COU_START_DATE, COU_END_DATE, COU_CODE)
        VALUES(OPENING_COURSES_SEQ.NEXTVAL, V_ROOM_CODE, V_COU_START_DATE, V_COU_END_DATE, V_COU_CODE);
        COMMIT;
    ELSE
        RAISE_APPLICATION_ERROR(-20011, '해당 강의실에 이미 해당 과정이 개설되어 있습니다.');
    END IF;

EXCEPTION
    WHEN DUP_VAL_ON_INDEX THEN
        RAISE_APPLICATION_ERROR(-20006, '이미 해당 강의실에 해당 과정이 개설되어 있습니다.');
    WHEN USER_DEFINE_ERROR THEN
        ROLLBACK;
        RAISE;
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE;
END;

--○ 과정당 여러 학생 사전 등록 / 입력정보(학생이름, 주민번호 뒷자리) + 학생아이디 PROCEDURE
CREATE OR REPLACE PROCEDURE PRC_COURSE_APPLICATION_INSERT (
    P_ID            IN STUDENTS.STU_ID%TYPE,
    P_SSN           IN STUDENTS.STU_SSN%TYPE,
    P_OPEN_COU_CODE IN OPENING_COURSES.OPEN_COU_CODE%TYPE
)
IS
    V_STUDENT_COUNT NUMBER;
    V_COURSE_COUNT NUMBER;
    V_COU_START_DATE OPENING_COURSES.COU_START_DATE%TYPE;
    V_COU_END_DATE OPENING_COURSES.COU_END_DATE%TYPE;
    V_EXISTING_END_DATE OPENING_COURSES.COU_END_DATE%TYPE;
    V_REG_DATE STUDENTS.STU_REG_DATE%TYPE;

    CURSOR ExistingCourses IS
        SELECT OC.COU_END_DATE
        FROM OPENING_COURSES OC
        JOIN COURSE_APPLICATION CA ON OC.OPEN_COU_CODE = CA.OPEN_COU_CODE
        WHERE CA.STU_ID = P_ID;

BEGIN
    -- 입력된 학생 ID가 존재하는지 확인
    SELECT COUNT(*)
    INTO V_STUDENT_COUNT
    FROM STUDENTS
    WHERE STU_ID = P_ID AND STU_SSN = P_SSN;

    IF V_STUDENT_COUNT = 0 THEN
        RAISE_APPLICATION_ERROR(-20001, '입력한 학생 정보가 올바르지 않습니다.');
    END IF;

    -- 학생 등록일 확인
    SELECT STU_REG_DATE
    INTO V_REG_DATE
    FROM STUDENTS
    WHERE STU_ID = P_ID AND STU_SSN = P_SSN;

    -- 학생 등록일과 수강신청일 비교하여 미래일 경우 예외처리
    IF V_REG_DATE > SYSDATE THEN
        RAISE_APPLICATION_ERROR(-20007, '수강신청일이 학생 가입일보다 미래입니다.');
    END IF;

    -- 해당 과정이 존재하는지 확인
    SELECT COUNT(*)
    INTO V_COURSE_COUNT
    FROM OPENING_COURSES
    WHERE OPEN_COU_CODE = P_OPEN_COU_CODE;

    IF V_COURSE_COUNT = 0 THEN
        RAISE_APPLICATION_ERROR(-20003, '해당 과목 코드가 존재하지 않습니다.');
    END IF;

    -- 이미 수강신청한 과목인지 확인
    FOR CourseRec IN ExistingCourses LOOP
        V_EXISTING_END_DATE := CourseRec.COU_END_DATE;
        EXIT WHEN V_EXISTING_END_DATE > SYSDATE; -- 첫 번째 이후 종료일을 찾음
    END LOOP;

    -- 새로운 과정의 시작일과 종료일 가져오기
    SELECT COU_START_DATE, COU_END_DATE
    INTO V_COU_START_DATE, V_COU_END_DATE
    FROM OPENING_COURSES
    WHERE OPEN_COU_CODE = P_OPEN_COU_CODE;

    -- 수강 과정이 종료되었을 경우 예외처리
    IF V_COU_END_DATE < SYSDATE THEN
        RAISE_APPLICATION_ERROR(-20008, '수강신청할 수 없습니다. 해당 과정이 이미 종료되었습니다.');
    END IF;

    -- 이미 수강한 과정들의 종료일과 비교하여 수강 신청 가능 여부 확인
    IF V_EXISTING_END_DATE <= V_COU_END_DATE THEN
        -- 신청하려는 과정의 종료일이 가장 최근 수강한 과목들의 종료일 이후인 경우
        INSERT INTO COURSE_APPLICATION (COU_APP_NUM, STU_ID, OPEN_COU_CODE, APP_DATE)
        VALUES (COURSE_APPLICATION_SEQ.NEXTVAL, P_ID, P_OPEN_COU_CODE, SYSDATE);
    ELSE
        RAISE_APPLICATION_ERROR(-20005, '해당 과목의 수강신청 기간이 아닙니다.');
    END IF;

    COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE;
END;


--○ 중도탈락자 등록
CREATE OR REPLACE PROCEDURE PRC_RETIRE_OUT_STUDENTS_INSERT (
    V_RETIRE_NO         IN RETIRE_OUT_STUDENTS.RETIRE_NO%TYPE,
    V_RETIRE_DATE       IN RETIRE_OUT_STUDENTS.RETIRE_DATE%TYPE,
    V_RETIRE_CODE       IN RETIRE_OUT_STUDENTS.RETIRE_CODE%TYPE,
    V_COU_APP_NUM       IN COURSE_APPLICATION.COU_APP_NUM%TYPE 
)
IS
    V_RETIRE_OUT_REASON_COUNT NUMBER;
    V_APP_DATE          COURSE_APPLICATION.APP_DATE%TYPE;
    V_OPEN_COU_CODE     COURSE_APPLICATION.OPEN_COU_CODE%TYPE;
    V_COU_START_DATE    OPENING_COURSES.COU_START_DATE%TYPE;
    V_COU_END_DATE      OPENING_COURSES.COU_END_DATE%TYPE;
    V_COUNT             NUMBER; -- 이 변수를 루프 내부에서 선언합니다.
    CURSOR RetireCheck IS
        SELECT COUNT(*)
        FROM RETIRE_OUT_STUDENTS 
        WHERE RETIRE_NO = V_RETIRE_NO AND RETIRE_CODE = V_RETIRE_CODE AND COU_APP_NUM = V_COU_APP_NUM;
    USER_DEFINE_ERROR   EXCEPTION;
    USER_DEFINE_ERROR2  EXCEPTION;
    USER_DEFINE_ERROR3  EXCEPTION;
    USER_DEFINE_ERROR4  EXCEPTION;
BEGIN
    -- 수강신청일 예외
    SELECT APP_DATE INTO V_APP_DATE
    FROM COURSE_APPLICATION
    WHERE COU_APP_NUM = V_COU_APP_NUM;

    IF V_RETIRE_DATE <= V_APP_DATE THEN
        RAISE USER_DEFINE_ERROR;
    END IF;

    -- 과정 신청일 예외
    SELECT OPEN_COU_CODE INTO V_OPEN_COU_CODE
    FROM COURSE_APPLICATION
    WHERE COU_APP_NUM = V_COU_APP_NUM;

    SELECT COU_START_DATE INTO V_COU_START_DATE
    FROM OPENING_COURSES
    WHERE OPEN_COU_CODE = V_OPEN_COU_CODE;

    SELECT COU_END_DATE INTO V_COU_END_DATE
    FROM OPENING_COURSES
    WHERE OPEN_COU_CODE = V_OPEN_COU_CODE;

    IF V_RETIRE_DATE NOT BETWEEN V_COU_START_DATE AND V_COU_END_DATE THEN
        RAISE USER_DEFINE_ERROR2;
    END IF;

    -- 중도탈락 사유가 존재하는지 확인
    SELECT COUNT(*)
    INTO V_RETIRE_OUT_REASON_COUNT
    FROM RETIRE_OUT_REASON
    WHERE RETIRE_CODE = V_RETIRE_CODE;

    IF V_RETIRE_OUT_REASON_COUNT = 0 THEN
        RAISE USER_DEFINE_ERROR3;
    END IF;

    -- 중복된 데이터 확인
    OPEN RetireCheck;
    BEGIN
        FETCH RetireCheck INTO V_COUNT;
        IF V_COUNT > 0 THEN 
            RAISE USER_DEFINE_ERROR4;
        END IF;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            V_COUNT := 0;
    END;
    CLOSE RetireCheck;

    -- 중복이 없다면 데이터 삽입
    IF V_COUNT = 0 THEN 
        INSERT INTO RETIRE_OUT_STUDENTS (RETIRE_NO, RETIRE_DATE, RETIRE_CODE, COU_APP_NUM)
        VALUES (V_RETIRE_NO, V_RETIRE_DATE, V_RETIRE_CODE, V_COU_APP_NUM);
    END IF;

EXCEPTION
    WHEN USER_DEFINE_ERROR THEN
        RAISE_APPLICATION_ERROR(-20080, '수강신청일 보다 이전에는 등록할 수 없습니다.');
        ROLLBACK;
    WHEN USER_DEFINE_ERROR2 THEN
        RAISE_APPLICATION_ERROR(-20081, '과정기간일이 아니라면 등록할 수 없습니다.');
        ROLLBACK;
    WHEN USER_DEFINE_ERROR3 THEN
        RAISE_APPLICATION_ERROR(-20082, '중도탈락 사유가 존재하지 않습니다.');
        ROLLBACK;
    WHEN USER_DEFINE_ERROR4 THEN
        RAISE_APPLICATION_ERROR(-20083, '중복된 중도탈락 사유가 있습니다.');
        ROLLBACK;
    WHEN OTHERS THEN
        ROLLBACK;

    COMMIT;
END;


-- [사용자측 요구분석(교수)]

--○ 교수 로그인 PROCEDURE
CREATE OR REPLACE PROCEDURE PRC_PRO_LOGIN
( V_ID  IN PROFESSORS.PRO_ID%TYPE
, V_PW  IN PROFESSORS.PRO_PW%TYPE
)
IS
    V_PRO_NAME          PROFESSORS.PRO_NAME%TYPE;
BEGIN

    SELECT PRO_NAME INTO V_PRO_NAME
    FROM PROFESSORS
    WHERE PRO_ID = V_ID
          AND
          PRO_PW = V_PW;


    IF (V_PRO_NAME IS NOT NULL)
        THEN DBMS_OUTPUT.PUT_LINE('【' || V_PRO_NAME || '교수님, 환영합니다.】');
    END IF;


    EXCEPTION 
        WHEN OTHERS
        THEN DBMS_OUTPUT.PUT_LINE('로그인 정보가 확인되지 않았습니다.');

END;

--○ 과목별 배점 결정 PROCEDURE
CREATE OR REPLACE PROCEDURE BAEJEOM_PRC
( V_OPEN_SUB_CODE   IN OPENING_SUBJECTS.OPEN_SUB_CODE%TYPE
--① [과목 코드 입력]

, V_NOTE_RATIO       IN OPENING_SUBJECTS.ATT_RATIO%TYPE
--② [필기 점수 배점]

, V_SKILL_RATIO      IN OPENING_SUBJECTS.NOTE_RATIO%TYPE
--③ [실기 점수 배점]    

, V_ATT_RATIO     IN OPENING_SUBJECTS.SKILL_RATIO%TYPE
--④ [출결 점수 배점]
)
IS
    V_RATIO_TOTAL       NUMBER(5) := V_ATT_RATIO + V_NOTE_RATIO + V_SKILL_RATIO;
    USER_DEFINE_ERROR   EXCEPTION;
BEGIN

    IF ((MOD(V_ATT_RATIO, 10) + MOD(V_NOTE_RATIO, 10) + MOD(V_SKILL_RATIO, 10)  = 0)
            -- ⓐ[출결 배점을 10으로 나눈 나머지가 0 = 10의 배수형태로 입력됐음을 의미합니다.]
            -- ⓑ[필기 배점을 10으로 나눈 나머지가 0 = 10의 배수형태로 입력됐음을 의미합니다.]
            -- ⓒ[실기 배점을 10으로 나눈 나머지가 0 = 10의 배수형태로 입력됐음을 의미합니다.]
           AND (V_RATIO_TOTAL = 100))  
            -- ⓓ[모든 배점의 총합이 100이 맞다면]

            -- ▶[업데이트를 수행합니다.]****************************************
            THEN UPDATE OPENING_SUBJECTS
                 SET  ATT_RATIO = V_ATT_RATIO
                   , NOTE_RATIO = V_NOTE_RATIO
                   , SKILL_RATIO = V_SKILL_RATIO
                 WHERE OPEN_SUB_CODE = V_OPEN_SUB_CODE;
             --◎[매개변수로 입력받은 개설과목 코드의 배점을 업데이트 합니다.]
            --******************************************************************

    ELSE RAISE USER_DEFINE_ERROR;
        --※[제대로 된 배점값을 입력하지 않았을 경우 사용자 정의 에러를 발생시킵니다.]

    END IF;


    EXCEPTION
        WHEN USER_DEFINE_ERROR
        THEN RAISE_APPLICATION_ERROR(-20011, '【입력한 배점 중 10의 배수가 아닌 값이 있거나, 배점의 총합이 100이 아닙니다.】');
             ROLLBACK;

        WHEN OTHERS
        THEN ROLLBACK;


    COMMIT;

END;

--○ 강의 했던 강의과목 출력 VIEW
CREATE OR REPLACE VIEW VIEW_PROFESSORS_SUB ("과정명", "과목명", "개설과목시작일", "개설과목종료일", "교수자 ID", "담당교수명") AS 
(
    SELECT C.COU_NAME "과정명", S.SUB_NAME "과목명"
         , OS.SUB_START_DATE "개설과목시작일"
         , OS.SUB_END_DATE   "개설과목종료일"
         , OS.PRO_ID         "교수자 ID"
         , P.PRO_NAME        "담당교수명"
    FROM COURSE_APPLICATION CA
         INNER JOIN OPENING_COURSES OS
         ON CA.OPEN_COU_CODE = OS.OPEN_COU_CODE
         INNER JOIN COURSES C
         ON OS.COU_CODE = C.COU_CODE
         INNER JOIN OPENING_SUBJECTS OS
         ON OS.OPEN_COU_CODE = CA.OPEN_COU_CODE
         INNER JOIN SUBJECTS S
         ON S.SUB_CODE = OS.SUB_CODE
         INNER JOIN PROFESSORS P
         ON OS.PRO_ID = P.PRO_ID
);


--○ 수강 학생 이름 출력 VIEW
CREATE OR REPLACE VIEW CHECK_MY_STUDENTS_VIEW ("수강신청번호", "과목 코드", "과정명", "과목명", "필기배점", "실기배점", 
                                               "출결배점", "학생 ID", "학생명", "과목 시작일", "과목 종료일", "교수아이디", "교수명") AS 
(
    SELECT CA.COU_APP_NUM    "수강신청번호", OS.OPEN_SUB_CODE "과목 코드"
         , C.COU_NAME        "과정명"      , S.SUB_NAME       "과목명"
         , OS.NOTE_RATIO     "필기배점"    , OS.SKILL_RATIO   "실기배점"
         , OS.ATT_RATIO      "출결배점"
         , STU.STU_ID        "학생 ID"     , STU.STU_NAME     "학생명"
         , OS.SUB_START_DATE "과목 시작일"  , OS.SUB_END_DATE  "과목 종료일"
         , OS.PRO_ID         "교수아이디"  , P.PRO_NAME       "교수명"
    FROM COURSE_APPLICATION CA
         INNER JOIN
         STUDENTS STU
         ON STU.STU_ID = CA.STU_ID
         INNER JOIN
         OPENING_COURSES OC
         ON OC.OPEN_COU_CODE = CA.OPEN_COU_CODE
         INNER JOIN 
         OPENING_SUBJECTS OS
         ON OS.OPEN_COU_CODE = OC.OPEN_COU_CODE
         INNER JOIN
         SUBJECTS S
         ON S.SUB_CODE = OS.SUB_CODE
         INNER JOIN
         COURSES C
         ON C.COU_CODE =OC.COU_CODE
         INNER JOIN
         PROFESSORS P
         ON OS.PRO_ID = P.PRO_ID
);

--○ 성적 입력 가능한 수강신청 학생 조회 VIEW

CREATE OR REPLACE VIEW GRADES_AVAILABLE_VIEW 
("성적코드", "개설과정코드", "개설과목코드", "수강신청번호", "중도탈락여부", "중도탈락일자", "개설과목시작일", "개설과목종료일", "필기점수", "실기점수", "출결점수", "총점", "필기배점", "실기배점", "출결배점") AS 
(
    SELECT S.SCORE_CODE      "성적코드"
         , OS.OPEN_COU_CODE  "개설과정코드"
         , S.OPEN_SUB_CODE   "개설과목코드"
         , S.COU_APP_NUM    "수강신청번호"
         , CASE WHEN CRS.중도탈락수강신청 IS NOT NULL
                THEN '중도탈락자'
                WHEN CRS.중도탈락수강신청 IS NULL
                THEN '수료생'
                ELSE '알 수 없음.'
            END              "중도탈락여부"
         ,  CRS.중도탈락일자  "중도탈락일자"
         ,  OS.SUB_START_DATE "개설과목시작일"
         ,  OS.SUB_END_DATE   "개설과목종료일"
         ,  S.NOTE_SCORE     "필기점수"
         ,  S.SKILL_SCORE    "실기점수"
         ,  S.ATT_SCORE      "출결점수"
         ,  S.NOTE_SCORE + S.SKILL_SCORE + S.ATT_SCORE "총점"
         ,  OS.NOTE_RATIO    "필기배점"
         ,  OS.SKILL_RATIO   "실기배점"
         ,  OS.ATT_RATIO     "출결배점"
    FROM CHECK_RETIRE_STU_VIEW CRS
         RIGHT OUTER JOIN SCORE S
         ON CRS.개설과목코드 = S.OPEN_SUB_CODE
            AND
            CRS.중도탈락수강신청 = S.COU_APP_NUM
         INNER JOIN OPENING_SUBJECTS OS
         ON S.OPEN_SUB_CODE = OS.OPEN_SUB_CODE
);



--○ 성적 처리
CREATE OR REPLACE TRIGGER TRG_NULL_SCORE
       AFTER
       INSERT ON COURSE_APPLICATION

DECLARE
    V_SC_CODE           SCORE.SCORE_CODE%TYPE;
    V_COU_APP_NUM       COURSE_APPLICATION.COU_APP_NUM%TYPE;
    V_OPEN_SUB_CODE     OPENING_SUBJECTS.OPEN_SUB_CODE%TYPE;

    CURSOR CAN_OSC_CUR
    IS
    SELECT COU_APP_NUM "수강신청번호" , OPEN_SUB_CODE "개설과목코드"
    FROM COURSE_APPLICATION CA
         INNER JOIN
         STUDENTS STU
         ON CA.STU_ID = STU.STU_ID
         INNER JOIN OPENING_COURSES OC
         ON CA.OPEN_COU_CODE = OC.OPEN_COU_CODE
         INNER JOIN OPENING_SUBJECTS OS
         ON OC.OPEN_COU_CODE = OS.OPEN_COU_CODE  
    --◎【수강신청 번호가 성적 테이블에 존재하지 않는 데이터들만 NULL 값 입력.】
    --**********************************
    WHERE COU_APP_NUM   
          NOT IN
          (
            SELECT COU_APP_NUM
            FROM SCORE
          );
    --**********************************  

BEGIN

    IF (INSERTING)
        THEN
            OPEN CAN_OSC_CUR;

            LOOP

                 --①[자동적으로 성적 코드 생성]
                SELECT 'SC' || LPAD(NVL(MAX(TO_NUMBER(SUBSTR(SCORE_CODE, 3, 4))) , 0) + 1, 4, '0') INTO V_SC_CODE
                FROM SCORE;

                FETCH CAN_OSC_CUR INTO V_COU_APP_NUM, V_OPEN_SUB_CODE;

                EXIT WHEN CAN_OSC_CUR%NOTFOUND;

                INSERT INTO SCORE(SCORE_CODE, OPEN_SUB_CODE, COU_APP_NUM)
                VALUES(V_SC_CODE, V_OPEN_SUB_CODE, V_COU_APP_NUM);


            END LOOP;

    END IF;


END;


--○ 성적 입력 / 수정 ※중도탈락자 제외 PROCEDURE
CREATE OR REPLACE PROCEDURE PRC_UPDATE_SCORE
( V_OPEN_SUB_CODE   IN OPENING_SUBJECTS.OPEN_SUB_CODE%TYPE
, V_COU_APP_NUM     IN COURSE_APPLICATION.COU_APP_NUM%TYPE
, V_NOTE_SCORE      IN SCORE.NOTE_SCORE%TYPE
, V_SKILL_SCORE     IN SCORE.SKILL_SCORE%TYPE
, V_ATT_SCORE       IN SCORE.ATT_SCORE%TYPE
)
IS
    --[업데이트 조건에 맞지 않을경우 에러 발생.]
    
    USER_DEFINE_ERROR   EXCEPTION;
    USER_DEFINE_ERROR2  EXCEPTION;


    --『중도탈락자 테이블의 정보 조회 CURSOR』〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓
    -- CURSOR 【YOU_RETIRE_STU_CUR】
    --******************************
    -- ① 중도탈락수강번호
    -- ② 중도탈락일
    -- ③ 개설과정코드
    --******************************
    CURSOR YOU_RETIRE_STU_CUR
    IS
    SELECT CA.COU_APP_NUM "중도탈락수강번호", ROS.RETIRE_DATE "중도탈락일", OC.OPEN_COU_CODE "개설과정코드"
    FROM RETIRE_OUT_STUDENTS ROS
         INNER JOIN COURSE_APPLICATION CA
                 ON ROS.COU_APP_NUM = CA.COU_APP_NUM
         INNER JOIN OPENING_COURSES OC
                 ON CA.OPEN_COU_CODE = OC.OPEN_COU_CODE
         INNER JOIN COURSES C
                 ON OC.COU_CODE = C.COU_CODE;
    --〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓


    --『중도탈락자』-------------------------------------------
    V_RETIRE_CA_NUM     RETIRE_OUT_STUDENTS.COU_APP_NUM%TYPE;
    -- ⓐ [중도탈락 수강번호]
    V_RETIRE_DATE       RETIRE_OUT_STUDENTS.RETIRE_DATE%TYPE;
    -- ⓑ [중도탈락일자]
    V_RETIRE_COU_CODE   OPENING_COURSES.OPEN_COU_CODE%TYPE;
    -- ⓒ [중도탈락자가 참여한 개설과정코드]
    ----------------------------------------------------------

    --『로그인한 교수의 과목, 과정』----------------------------
    V_SUB_END_DATE      OPENING_SUBJECTS.SUB_END_DATE%TYPE;
    -- ⓐ [개설과목 종료일자]
    V_OPEN_COU_CODE     OPENING_COURSES.OPEN_COU_CODE%TYPE;
    -- ⓑ [개설과목이 포함된 개설과정코드]
    -----------------------------------------------------------
    V_NOTE_RATIO        OPENING_SUBJECTS.NOTE_RATIO%TYPE;
    V_SKILL_RATIO       OPENING_SUBJECTS.SKILL_RATIO%TYPE;
    V_ATT_RATIO         OPENING_SUBJECTS.ATT_RATIO%TYPE;


BEGIN
        --【V_OPEN_COU_CODE】*********************
    --[개설 과목의 개설과정코드 변수에 담기]
    SELECT OPEN_COU_CODE INTO V_OPEN_COU_CODE
    FROM OPENING_SUBJECTS
    WHERE OPEN_SUB_CODE = V_OPEN_SUB_CODE;
    --********************************************

    --【V_SUB_END_DATE】*************************
    --[개설 과목의 종료일자 변수에 담기]
    SELECT SUB_END_DATE INTO V_SUB_END_DATE
    FROM OPENING_SUBJECTS
    WHERE OPEN_SUB_CODE = V_OPEN_SUB_CODE;
    --********************************************


    SELECT NOTE_RATIO, SKILL_RATIO, ATT_RATIO
           INTO 
           V_NOTE_RATIO, V_SKILL_RATIO, V_ATT_RATIO
    FROM OPENING_SUBJECTS
    WHERE OPEN_SUB_CODE = V_OPEN_SUB_CODE;


    --【OPEN YOU_RETIRE_STU_CUR】************************************************
    --[커서를 열어서, 중도탈락자 학생들을 한 명씩 조회하기]

    OPEN YOU_RETIRE_STU_CUR;

    LOOP

        FETCH YOU_RETIRE_STU_CUR INTO V_RETIRE_CA_NUM, V_RETIRE_DATE, V_RETIRE_COU_CODE;

        IF (SYSDATE > V_SUB_END_DATE)
            THEN

            IF ((V_RETIRE_COU_CODE = V_OPEN_COU_CODE)
                AND
                (V_RETIRE_CA_NUM = V_COU_APP_NUM)
                AND
                (V_RETIRE_DATE < V_SUB_END_DATE))

                THEN DBMS_OUTPUT.PUT_LINE('▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒');
                     DBMS_OUTPUT.PUT_LINE('중도탈락자의 성적은 입력할 수 없습니다.');
                     DBMS_OUTPUT.PUT_LINE('중도탈락일 : '    || V_RETIRE_DATE);
                     DBMS_OUTPUT.PUT_LINE('수강신청 번호 : ' || V_RETIRE_CA_NUM);
                     DBMS_OUTPUT.PUT_LINE('▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒');
                     RAISE USER_DEFINE_ERROR;

            END IF;

        ELSIF (SYSDATE <= V_SUB_END_DATE)
            THEN

             DBMS_OUTPUT.PUT_LINE('▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒');
             DBMS_OUTPUT.PUT_LINE('입력한 개설과목코드의 과목이 아직 종료되지 않았습니다.');
             DBMS_OUTPUT.PUT_LINE('   과목이 종료된 이후에 성적을 입력해 주십시오.');
             DBMS_OUTPUT.PUT_LINE('▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒');
             RAISE USER_DEFINE_ERROR2;

        END IF;

        EXIT WHEN YOU_RETIRE_STU_CUR%NOTFOUND;

        DBMS_OUTPUT.PUT_LINE(V_RETIRE_CA_NUM || '   ' || V_RETIRE_DATE);

    END LOOP;
    --**************************************************************************

    UPDATE SCORE
    SET   NOTE_SCORE = V_NOTE_SCORE * (V_NOTE_RATIO / 100)
        , SKILL_SCORE = V_SKILL_SCORE * (V_SKILL_RATIO / 100)
        , ATT_SCORE   = V_ATT_SCORE * (V_ATT_RATIO / 100)
    WHERE COU_APP_NUM = V_COU_APP_NUM
          AND
          OPEN_SUB_CODE = V_OPEN_SUB_CODE;

    EXCEPTION
        WHEN USER_DEFINE_ERROR
        THEN RAISE_APPLICATION_ERROR(-20012, '입력하신 수강신청번호의 학생은 본 과정의 중도 탈락자입니다. 성적 입력이 불가능합니다.');
             ROLLBACK;

        WHEN USER_DEFINE_ERROR2
        THEN RAISE_APPLICATION_ERROR(-20013, '개설 과목 진행이 종료된 이후에 성적을 입력해 주십시오.');
             ROLLBACK;

        WHEN OTHERS
        THEN ROLLBACK;

    COMMIT;

END;

--○ 성적 정보 삭제 PROCEDURE
CREATE OR REPLACE PROCEDURE PRC_SCORE_DELETE
( V_COU_APP_NUM    IN COURSE_APPLICATION.COU_APP_NUM%TYPE       -- 수강신청번호
, V_OPEN_SUB_CODE  IN OPENING_SUBJECTS.OPEN_SUB_CODE%TYPE       -- 개설과목코드
)
IS
BEGIN
    DELETE
    FROM SCORE
    WHERE COU_APP_NUM = V_COU_APP_NUM AND OPEN_SUB_CODE = V_OPEN_SUB_CODE;

    COMMIT;
END;


--○ 성적 출력 / 출력내용(과목명, 과목기간, 교재명, 학생명, 출력, 실기, 필기, 총점, 등수) VIEW
CREATE OR REPLACE VIEW VIEW_SCORE ("과목명", "과목시작일", "과목끝일", "교재명", "학생명", "필기성적"
, "실기성적", "출결성적", "총점", "교수아이디", "등수") AS 
SELECT T."과목명",T."과목시작일",T."과목끝일",T."교재명",T."학생명",T."필기성적",T."실기성적"
,T."출결성적",T."총점",T."교수아이디", RANK() OVER(PARTITION BY T.과목명 ORDER BY T. 총점) "등수"
FROM
(SELECT SUB_NAME "과목명", SUB_START_DATE "과목시작일", SUB_END_DATE "과목끝일"
, BOOK_NAME "교재명", STU_NAME "학생명", NOTE_SCORE "필기성적", SKILL_SCORE "실기성적"
, ATT_SCORE "출결성적", NOTE_SCORE+SKILL_SCORE+ATT_SCORE "총점", PRO_ID "교수아이디"
FROM SUBJECTS JOIN OPENING_SUBJECTS
ON SUBJECTS.SUB_CODE = OPENING_SUBJECTS.SUB_CODE
    JOIN BOOKS
    ON BOOKS.BOOK_CODE = OPENING_SUBJECTS.BOOK_CODE
        JOIN SCORE
        ON SCORE.OPEN_SUB_CODE = OPENING_SUBJECTS.OPEN_SUB_CODE
            JOIN COURSE_APPLICATION
            ON SCORE.COU_APP_NUM = COURSE_APPLICATION.COU_APP_NUM
                JOIN STUDENTS
                ON COURSE_APPLICATION.STU_ID = STUDENTS.STU_ID
) T
WHERE T.총점 IS NOT NULL;

--○ 중도탈락자 출력 VIEW
CREATE OR REPLACE VIEW CHECK_RETIRE_STU_VIEW ("중도탈락일자", "중도탈락수강신청", "중도탈락과정코드"
, "개설과목코드", "개설과목 시작일", "개설과목 종료일", "개설과목개설과정") AS 
(
    SELECT ROS.RETIRE_DATE "중도탈락일자"
         , ROS.COU_APP_NUM "중도탈락수강신청"
         , OC.OPEN_COU_CODE "중도탈락과정코드"
         , OS.OPEN_SUB_CODE "개설과목코드"
         , OS.SUB_START_DATE "개설과목 시작일"
         , OS.SUB_END_DATE "개설과목 종료일"
         , OS.OPEN_COU_CODE "개설과목개설과정"
    FROM RETIRE_OUT_STUDENTS ROS
         INNER JOIN
         COURSE_APPLICATION CA
                 ON ROS.COU_APP_NUM = CA.COU_APP_NUM
         INNER JOIN
         OPENING_COURSES OC
                 ON CA.OPEN_COU_CODE = OC.OPEN_COU_CODE
         INNER JOIN
         OPENING_SUBJECTS OS
                 ON OS.OPEN_COU_CODE = OC.OPEN_COU_CODE
    WHERE ROS.RETIRE_DATE < OS.SUB_END_DATE
          AND
          OC.OPEN_COU_CODE = OS.OPEN_COU_CODE

);


-- [사용자측 요구분석(학생)]

--○ 학생 로그인
create or replace PROCEDURE PRC_STU_LOGIN
( V_ID  IN STUDENTS.STU_ID%TYPE
, V_PW  IN STUDENTS.STU_PW%TYPE
)
IS
    V_STU_NAME          STUDENTS.STU_NAME%TYPE;
BEGIN

    SELECT STU_NAME INTO V_STU_NAME
    FROM STUDENTS
    WHERE STU_ID = V_ID
          AND
          STU_PW = V_PW;


    IF (V_STU_NAME IS NOT NULL)
        THEN DBMS_OUTPUT.PUT_LINE('【' || V_STU_NAME || ' 학생, 환영합니다.】');
    END IF;


    EXCEPTION 
        WHEN OTHERS
        THEN DBMS_OUTPUT.PUT_LINE('로그인 정보가 확인되지 않았습니다.');

END;

--○ 성적 출력 / 출력정보(학생이름, 과정명, 과목명, 교육기간, 교재명, 출결, 실기, 필기, 총점, 등수)
--   -> 중도탈락자라도 이미 수강한 과목은 정보출력 
CREATE OR REPLACE VIEW WHAT_ARE_MY_GRADES_VIEW ("학생이름", "학생ID", "과정명", "과목명"
, "과목 시작일", "과목 종료일", "교재명", "필기 점수", "실기 점수", "출결 점수", "총점", "과목별 등수") AS 
  (
    SELECT STU.STU_NAME             "학생이름"
         , STU.STU_ID               "학생ID"
         , C.COU_NAME               "과정명"
         , SUB_NAME                 "과목명"
         , OS.SUB_START_DATE        "과목 시작일"
         , OS.SUB_END_DATE          "과목 종료일"
         , B.BOOK_NAME              "교재명"
         , NVL(SC.NOTE_SCORE, 0)    "필기 점수"
         , NVL(SC.SKILL_SCORE, 0)   "실기 점수"
         , NVL(SC.ATT_SCORE, 0)     "출결 점수"
         , NVL(SC.ATT_SCORE + SC.NOTE_SCORE + SC.SKILL_SCORE, 0) "총점"
         , RANK() OVER (PARTITION BY S.SUB_CODE ORDER BY SC.ATT_SCORE + SC.NOTE_SCORE + SC.SKILL_SCORE) "과목별 등수"
    FROM COURSE_APPLICATION CA
         INNER JOIN OPENING_COURSES OC
         ON CA.OPEN_COU_CODE = OC.OPEN_COU_CODE
         INNER JOIN OPENING_SUBJECTS OS
         ON OC.OPEN_COU_CODE = OS.OPEN_COU_CODE
         INNER JOIN SUBJECTS S
         ON OS.SUB_CODE = S.SUB_CODE
         INNER JOIN BOOKS B
         ON OS.BOOK_CODE = B.BOOK_CODE
         INNER JOIN STUDENTS STU
         ON CA.STU_ID = STU.STU_ID
         INNER JOIN COURSES C
         ON OC.COU_CODE = C.COU_CODE
         INNER JOIN SCORE SC
         ON CA.COU_APP_NUM = SC.COU_APP_NUM
            AND
            SC.OPEN_SUB_CODE = OS.OPEN_SUB_CODE
);

































